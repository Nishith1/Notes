🕐 Interview Structure (60 min)
Time	Area	Focus
0–5 min	Intro	Quick background discussion
5–25 min	Core Java + API Development	OOPs, REST API coding & error handling
25–45 min	Spring Boot + Microservices	Real-world implementation questions
45–55 min	CI/CD + Deployment	DevOps basics, Kafka & AWS
55–60 min	Q&A / Wrap-up	Candidate questions
🧠 1. Core Java & OOPs (5–25 min)

These test whether they can code cleanly and handle backend tasks independently.

What is the difference between == and .equals() in Java?

Explain how HashMap works internally. Why should hashCode and equals be overridden together?

How do you handle exceptions in a layered application? Can you give a real example?

Can you explain the difference between checked and unchecked exceptions with an example?

Explain how you would make a class immutable in Java.

How do you use Streams and Lambda in day-to-day development?

Write a simple function to remove duplicates from a list of integers using Streams. (live or whiteboard)

⚙️ 2. REST API & Spring Boot (25–45 min)

Most of their daily work will be here — coding, bug fixing, writing services, and calling APIs.

Explain the flow of a REST API call in a Spring Boot application.

How do you define a REST endpoint in Spring Boot? (Ask them to write a small example)

How do you handle validation in Spring Boot APIs? (Bean Validation / @Valid)

How do you handle global exceptions in a microservice? (ControllerAdvice / ExceptionHandler)

How do you secure an API using Spring Security or basic authentication?

What are @Component, @Service, @Repository, and how are they different?

How do you use profiles in Spring Boot for different environments (dev/test/prod)?

Explain how you externalize configuration in Spring Boot.

What are common HTTP status codes you return in APIs? When do you use each?

🧪 Live scenario example:

“You have to create a POST /users API to save a new user in DB. Walk me through:

the layers you’ll create,

annotations you’ll use,

how you’ll validate input and return response.”

☁️ 3. Kafka, Microservices & Cloud Basics (45–55 min)

Many of the resumes you shared include Kafka, AWS, Docker, ECS, etc.

What is Kafka and where have you used it? (Producer / Consumer flow)

How will you handle Kafka message failures? (retry / DLQ)

How will you deploy a Spring Boot app in ECS or Kubernetes? (high level)

What are the common AWS services you’ve used? (S3, ECS, EC2, RDS — check actual resume claims)

What is the difference between monolithic and microservice architecture?

How do you implement inter-service communication in microservices? (REST, Feign, Kafka, etc.)

Explain Circuit Breaker pattern and where you would use it.

How do you monitor services? (Splunk, CloudWatch, etc.)

🧰 4. DevOps & Practical Know-how (55–60 min)

These will help filter candidates who can deploy without hand-holding.

Explain how CI/CD works in your project. Which tools are used?

What is the difference between Jenkins pipeline and GitHub Actions?

How do you do rollback in case of a bad deployment?

How do you handle property management across environments?

Have you worked with SonarQube? What kinds of issues does it detect?

🧪 Optional Coding Exercise (if time permits or pre-assignment)

Ask the candidate to:

Write a simple Spring Boot REST endpoint that:

Accepts JSON input

Validates it

Saves to a dummy in-memory list or Map

Returns proper success/failure response

This small exercise will immediately separate theoretical candidates from practical developers.

✅ Evaluation Guidelines
Skill Area	Good Candidate	Red Flag
Core Java	Clear understanding of Collections, OOP, exceptions	Vague, can’t explain hashCode/equals
API Development	Can write & explain a REST endpoint confidently	Only talks theory
Spring Boot	Explains layers, annotations, validation, error handling	Confused between annotations / layers
Deployment	Familiar with Jenkins, Git, ECS/K8s, basic CI/CD	Has “heard of it” but can’t explain
Kafka & Cloud	Basic working knowledge	No clarity on producer-consumer flow
Communication	Explains flow clearly, owns work	Blames infra or others











Here’s a 15-minute practical coding task specifically designed for vendor/contractual Java Spring Boot developers who will be doing low-level coding, API development, and deployments.

This task is simple enough to complete quickly, but reveals a lot about their actual ability to write clean, working code.

🧪 15-Minute Coding Task: “User Management API”
📝 Problem Statement

Build a simple Spring Boot REST API to manage users.

Create an API endpoint:

POST /users — accepts a JSON request body with user details and saves it to an in-memory list or map.

GET /users — returns the list of all users.

📥 Example Request
POST /users
{
  "id": 1,
  "name": "John Doe",
  "email": "john.doe@example.com"
}

📤 Example Response (POST success)
{
  "message": "User added successfully"
}

📤 Example Response (GET)
[
  {
    "id": 1,
    "name": "John Doe",
    "email": "john.doe@example.com"
  }
]

✅ Evaluation Criteria
Area	What to Look For	Bonus
Spring Boot Setup	Can create a controller with proper annotations (@RestController, @PostMapping, @GetMapping)	Uses proper project structure (controller, service, model)
JSON Mapping	Uses @RequestBody properly	Uses DTO/model cleanly
Validation	At least checks basic null values / required fields	Uses @Valid and Bean Validation annotations
Data Handling	Uses a static list or ConcurrentHashMap to store users	Separation of layers (service class)
Response Handling	Returns proper JSON response	Returns ResponseEntity with appropriate HTTP status
Code Quality	Clean, readable code	Uses meaningful names and exception handling
💡 Hints (Optional if they get stuck)

If the candidate is stuck after 5–7 mins, give these nudges:

“Use @RestController and @PostMapping for the API.”

“Use a static List or Map to store users in memory.”

“Don’t worry about database for now.”

🧰 Bonus Extensions (if they finish early) (Pick 1 or 2)

Add validation to ensure email is not blank.

Return 400 Bad Request if input is invalid.

Add DELETE /users/{id} endpoint to delete a user.

Log the API calls using @Slf4j or Logger.

🧑‍💻 What This Task Reveals

Whether they can code independently without copy-pasting.

How well they know Spring Boot annotations and structure.

How cleanly they handle request–response and basic validations.

How quickly they can get a working service up (a crucial skill for vendor devs).

👉 Tip for you during interview:

Share this task as a Google Doc / Paste in the meeting chat.

Let them screen share and code.

If they can’t finish in 15 mins, it’s still very telling how they approach the problem.

If they complete it smoothly, they’ll likely be able to handle real project tasks with minimal guidance.






Absolutely ✅
Since your team will have vendor/contractual developers doing low-level backend coding, API development, deployment, and integration, here’s an expanded list of structured technical interview questions — categorized by skill area.

This list goes beyond the basics, mixing practical scenario-based questions with conceptual ones to differentiate between candidates who’ve only “used” technologies and those who actually understand them.

🧠 1. Core Java & OOPs – Must-Have Fundamentals

These test their coding foundation and debugging ability.

Conceptual

What’s the difference between String, StringBuilder, and StringBuffer? When would you use each?

What is the difference between final, finally, and finalize()?

What happens if you don’t override hashCode() when overriding equals()?

What is the difference between Comparable and Comparator?

What is the difference between ArrayList and LinkedList? Which one is faster for insert/delete?

How does HashMap handle collisions?

Why is HashMap not thread-safe and what would you use instead in multithreading?

Practical/Scenario

Suppose you have a list of users. How will you remove duplicates based on ID? (Streams / loops)

How do you handle a NullPointerException in a clean way?

How do you make a class immutable?

How would you sort a list of employees by their names?

⚙️ 2. Spring Boot / REST API Development

Since most work will revolve around this, these are crucial.

Conceptual

What’s the difference between @Controller and @RestController?

How does dependency injection work in Spring?

What are @Component, @Service, @Repository, and how do they differ?

How does Spring Boot auto-configuration work?

How do you handle exceptions globally in Spring Boot?

What are the different scopes of beans in Spring?

How do you validate request payloads in Spring Boot?

Practical/Scenario

How would you secure a REST API without using a full authentication server?

How do you pass configuration values to your Spring Boot app for different environments?

Suppose your downstream API fails. How do you handle fallback gracefully?

If you have 3 microservices and 1 goes down, how would you keep the system stable?

How do you log incoming requests and outgoing responses?

☁️ 3. Microservices Architecture

Even if they won’t design the architecture, they should understand how services interact.

What’s the difference between Monolithic and Microservices architecture?

How do services communicate with each other in your project?

What is the purpose of service discovery (like Eureka)?

How would you handle failures in a distributed system?

What is a Circuit Breaker? Where would you use it?

What is idempotency and why is it important in APIs?

How do you version REST APIs in a microservice setup?

🔁 4. Kafka & Messaging

Many resumes mention Kafka. Good to test for real knowledge.

What is Kafka and why is it used?

What’s the difference between a Producer and a Consumer?

What is a Kafka topic and partition?

How do you handle message retries or dead-letter queues in Kafka?

How would you ensure exactly-once processing in Kafka?

How can you make sure your consumer doesn’t lose messages if the service restarts?

How would you handle out-of-order messages?

🧰 5. CI/CD, Deployment & DevOps Basics

They’ll often be doing deployments themselves.

What CI/CD tools have you worked with? (Jenkins, GitHub Actions, GitLab CI, etc.)

Walk me through your typical build → deploy process.

How do you handle environment-specific configurations during deployment?

What is the difference between ECS and EC2?

Have you worked with Docker? How do you create a Docker image for a Spring Boot app?

How do you roll back a deployment if something breaks?

How do you verify whether your deployed API is healthy?

🧪 6. Database & JPA

They’ll be doing basic CRUD operations and data handling.

What is the difference between @Entity and @Table in JPA?

What are the differences between lazy and eager loading?

How do you write a custom query in Spring Data JPA?

How do you handle transactions in Spring?

What’s the difference between save() and saveAndFlush() in JPA?

What is the N+1 select problem and how do you handle it?

How do you handle pagination in a Spring Boot API?

🧭 7. Logging, Monitoring & Error Handling

Useful for maintenance and debugging work.

How do you log in Spring Boot applications? (Log4j, SLF4J)

How do you log incoming requests and outgoing responses?

How would you trace errors in production?

What tools have you used for monitoring logs? (Splunk, CloudWatch, etc.)

How would you debug a sudden spike in 500 errors in your service?

What would you do if your service is up, but response times are very slow?

🧪 8. Testing & Quality

You’ll want devs who don’t break the build.

How do you write unit tests in Spring Boot?

Which testing frameworks have you used? (JUnit, Mockito, etc.)

What is the difference between a unit test and an integration test?

How do you mock external services in tests?

How do you verify your API behaves as expected before deployment?

🚨 9. Real-World Scenario Questions

These are very effective for vendor profiles because they reveal practical problem-solving skills.

“Your API suddenly starts returning 500 errors after deployment. What are the first 3 things you’ll check?”

“You deployed a new version, but the previous one was stable. How do you debug and roll back?”

“You need to deploy a fix at midnight. What steps will you take before and after the deployment?”

“A downstream service is failing intermittently. How will you make your service resilient?”

“How do you make an API idempotent?”

“What if Kafka messages are stuck in lag? How do you troubleshoot?”

🏁 Optional (If you want to push strong candidates)

Explain how you would implement rate limiting in a Spring Boot service.

How would you secure communication between two services?

How would you implement caching in a service? (e.g., using Redis or Caffeine)

How do you handle backward compatibility when changing API contracts?

✅ Pro Tip for Interviews

Pick 2–3 questions from each section rather than asking everything.

Start easy, then increase depth based on their answers.

Use “tell me how you did it in your project” — it quickly exposes bluffing.

Keep 1 practical scenario or coding question to ensure they can execute.
